Introduction to Programming Using C++ â€“ Level 2

This repository contains my solutions and practice work from the course Introduction to Programming Using C++ â€“ Level 2, taught by Dr. Mohammed Abo-Hadhoud.
The course focuses on strengthening programming fundamentals while diving deeper into memory management, data structures, file handling, and debugging using C++.

ðŸ“š Course Overview

This level builds on basic programming knowledge and helps develop a deeper understanding of how programs work internally. The course emphasizes thinking logically, writing clean and efficient code, and understanding memory and execution flow, not just syntax.

Key topics covered include:

Pointers and references

Memory addressing and pass-by-reference

Vectors and dynamic data handling

Iterators and safe container traversal

File input/output (read & write operations)

Debugging techniques and error analysis

Practical problem-solving using C++

ðŸŽ¯ Learning Objectives

By completing this course, I was able to:

Understand how memory works in C++

Use pointers and references correctly and safely

Replace raw arrays with vectors for flexible data management

Traverse containers using iterators

Read from and write to files for persistent storage

Debug programs logically and efficiently

Apply structured problem-solving techniques

ðŸ—‚ Repository Structure

The repository includes:

Organized problem solutions

Practical examples for each concept

Progressive exercises from simple to more advanced

Clean, readable, and well-structured C++ code

Each file focuses on a specific concept or problem and follows the problem-solving methodology taught in the course.

ðŸ›  Technologies Used

Language: C++

Compiler: Any standard-compliant C++ compiler (GCC / MSVC / Clang)

IDE: Any C++ supported IDE

ðŸš€ Why This Course Matters

This course is a critical step toward mastering Data Structures, Algorithms, and Advanced C++.
It reinforces the idea that strong fundamentals and deep understanding of memory and logic are essential for writing efficient, scalable, and reliable software.
